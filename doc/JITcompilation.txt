Переход из софтовой ВМ в JIT версию происходит посредством вызова примитива 252, в котором
мы вызываем функцию sendMessage (но не член-функцию SmalltalkVM::doSendMessage !!), куда передаем
привычный набор аргументов:
1) Текущий контекст
2) Селектор метода
3) Аргументы
4) Класс, у которого начинаем искать метод (в данном случае 0; используется для реализации sendToSuper)

В ходе исполнения функции sendMessage, как и в софтовой версии, происходит поиск метода, создаётся
новый контекст, у которого инициализируются все поля, за исключением стэка, он не используется в JIT;
метод компилируется и вызывается с 1 аргументом - новосозданным контекстом.

Во время компиляции метода создаётся функция вида "ClassName>>methodName" с аргументом TContext*,
создаётся первый BB - preable (преамбула), в которой мы создаём 2 переменные - pContext и pSelf,
которые являются зарученными значениями контекста-аргумента и объекта, которому послали вызов.

Вместо использования стэка из TContext для хранения значений, мы используем llvm::Value*. Например,
последовательность байткодов 'pushTemporary 1' и 'assignInstance 2' превратится в
'instanceVariables[2] = temporaries[1]', и код будет выглядеть:

%context = load %TContext** %pContext; pContext заручен, после GC его значение обновится
%temp.1  = call %TObject* @getTempFromContext(%TContext* %context, i32 1)
%self    = load %TObject* %pSelf
%instanceVariablePtr = call %TObject** getObjectFieldPtr(%TObject* %self, i32 2)
call void @checkRoot(%TObject* %temp.1, %TObject** %instanceVariablePtr)
store %TObject* %temp.1, %TObject** %instanceVariablePtr

Реализация blockReturn.

Пример кода:
METHOD MyClass
myMethod
    1 to: 10 do: [:i|
        ^i. "blockReturn"
    ].
!
При посылке сообщения myMethod объекту результатом всегда будет 1. Данный опкод является очень
интересным и необычным, так как мы возвращаем результат посылки сообщения из других контекстов.
В данном случае вложенность контекстов будет такова: myMethod >> (Interval) do: >> (Block) value: .
В софтовой версии его реализация не является проблемной, мы просто изменяем текущий контекст
выполнения с контекста блока на контекст метода, который породил данный блок (myMethod).
Но в JIT версии всё не так просто, потому что посылка сообщений является честным вызовом С++ функции,
и мы не можем взять и изменить текущий контекст выполнения присваиванием.

Нами было принято решение реализовать данный опкод с помощью исключений.
Перед началом кодогенерации мы сканируем байткоды метода на наличие опкода blockReturn. Если
данный опкод найден, то мы генерируем блок обработки исключений (landingpad BB), при посылке сообщений
call заменяется на invoke с указанием данного landingpad.

Когда мы встречаем опкод blockReturn, мы возбуждаем С++ исключение типа TBlockReturn с указанием
целевого контекста(контекста, который породил данный блок), и значением, которое необходимо вернуть
из метода.

Данное исключение ловится самым первым landingpad BB. Если целевой контекст блока равен контексту,
в котором было поймано исключение (currentContext == block->creatingContext), то мы возвращаем результат
из JIT функции, иначе данное исключение пробрасывается до тех пор, пока его не поймают и не обработают.
LLVM использует Itanium ABI zero cost exception handling http://llvm.org/docs/ExceptionHandling.html.

