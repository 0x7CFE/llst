Типы, как монадическая категория

Чистые функции без параметров:

    self::* -> self, 42
    foo
        ^42

    self::* -> self, (SmallInt)
    rnd
        ^SmallInt random


Чистые функции с параметрами:

Прямое связывание типа аргумента с типом функции
    id: param
        ^param

Т́иповое выражение:
    self::*, param::* -> self, param


Функция с двумя параметрами:
    sum: a and: b
        ^ a + b

Контекст object sum: intvara and: intvarb
    self::*, a::(SmallInt), b::(SmallInt) -> self', (SmallInt)

Контекст object sum: 2 and: 3
    self::*, a::2, b::3 -> self, 5

Обобщенный метод
    self::*, a::*, b::* -> self', *

то есть, литеральные значения протаскиваются прямо через тип


Чистый аксессор для объекта с одним полем:
    self::[_,_,field::*] -> self, field
    field
        ^field

Примитивный аксессор класса вне контекста:
    self::[_,class::*, ...] -> self, class
    class
        ^<2> "примитив getClass"

В контексте Object new class ти́повое выражение будет:
    self::[_,class::Class,_] -> self, class

(здесь class — это литеральное значение объекта метакласса, соответствующее классу объекта Object)


«Чистый» мутатор (линза?):
    self::[_,_,_], value::* -> self'::[_,_,value], self'
    field: value
        field <- value

Функция с побочным эффектом на объект:
    dirty: param
        field <- param
        ^param + 1

Вне контекста
    self::[_,_,_], param::* -> self'::[_,_,param], *

Контекст object dirty: intvar
    self::[_,_,_], param::(SmallInt) -> self'::[_,_,param], (SmallInt)

Контекст object dirty: 42
    self::[_,_,_], param::42 -> self'::[_,_,42], 43

Примечание: в случае утекания self, мы не можем утверждать, что self' будет таким. Придется фолбечиться на self'::*


А теперь самый вынос мозга — система контекста виртуальной машине — это моноид в категории эндофункторов! Монада то бишь.
Переход виртуальной машины от одного состояния к другому — это монадическая операция.

А это внезапно означает:

1. Трансформации типов при выполнении императивной программы выражаются ФУНКЦИОНАЛЬНЫМИ отношениями!!

Появляется понятие чистой ти́повой функции, когда тип результата чистым образом зависит от входных данных.
2. Паттерн матчинг! Ти́повые выражения можно рассматривать как шаблон подстановки или отображение типа аргументов в тип результата

Можно описать трансформации типов в духе подстановочных функций Хаскеля.

Например оператор * в общем случае подчиняется следующим шаблонам (сверху-вниз):

Арифметические отношения (чистота self следует из определения):
    self::(SmallInt), 0 -> self, 0
    self::(SmallInt), 1 -> self, (SmallInt)

Отношения для монотипов и литералов в частном порядке:
    self::(SmallInt), (SmallInt) -> self, (SmallInt)
    сюда попадут выражения «(SmallInt) * 5» и «5 * (SmallInt)» и «2 * 3»

Последним идет определение для общего случая:
    self::*, (SmallInt) -> self'::*, *


Фишка в том, что в вырожденных случаях можно определить тип результата (вплоть до литерального!) даже не подставляя функцию.
Более того, для литеральных контекстов можно вычислить значение функции даже на этапе компиляции.

Монадические отношения в связи с объектом self позволяют формализовать тот факт, что при вызове метода поля самого объекта не меняются.
Это позволяет более смело выполнять оптимизации и связывать далекие участки графа без опасения что типы совпали «случайно».

Поправка — нихрена :( Если self утек в другой объект, то вызывая методы он может поменять и нас. Только при инлайнинге и доказательсве.


Типы методов:
    - С побочными эффектами (грязный)
    - Без побочных эффектов на поля
    - С грязными блоками
    - С чистыми блоками
    - Без побочных эффектов (чистый)

Имеем метод
    test: a |x|
        x <- 42.
        a foo.
        a bar: [ x <- false ].
        x <- 'Hello'.
        a baz.

Вне контекста типы можно вывести следующим образом
(указывается значение на момент сразу после выполнения строки):
        x <- 42.               "x :: 42"
        a foo.                 "x :: 42"
        a bar: [ x <- false ]. "x :: (42, false)"
        x <- 'Hello'.          "x :: 'Hello'"
        a baz.                 "x :: ('Hello', false)"


Если анализ докажет, что блок не вызывается ни разу, то тип переменной x выводится литерально на диапазонах:
        x <- 42.               "x :: 42"
        a foo.                 "x :: 42"
        a bar: [ x <- false ]. "x :: 42"
        x <- 'Hello'.          "x :: 'Hello'"
        a baz.                 "x :: 'Hello'"


Если анализ докажет, что блок вызывается только в пределах bar (то есть, bar не имеет побочных эффектов относительно блока),
то типы выводятся следующим образом:

        x <- 42.               "x :: 42"
        a foo.                 "x :: 42"
        a bar: [ x <- false ]. "x :: (42, false)"
        x <- 'Hello'.          "x :: 'Hello'"
        a baz.                 "x :: 'Hello'"


На основании полноты информации можно очертить диапазон возможных значений переменной при выполнении кода.
Даже в условиях композитного типа в некоторых случаях можно провести анализ и девиртуализацию посылки сообщения.
В вышеприведенном методе, даже в худшем случае может быть показано, что переменная не выйдет за пределы диапазона
(42, false, 'Hello'). Соответственно, последующие посылки сообщений объекту x можно выполнить с оптимизациями.

В частности, если посылается сообщение с селектором, которому соответствует один и тот же метод для всех трех ветвей поиска,
то его можно вызвать обобщенном режиме. При этом, все обращения к полям, примитивам, self/super обрабатываются динамически.
Обобщенная реализация, будучи неспециализированной, может эффективно разделяться между многими классами, тем самым экономя ресурсы.

Например выражение x isNil может быть вычислено на этапе компиляции до литерального результата false, посколько для любой
из возможных ветвей результат будет идентичным (ни одна из ветвей не является потомком Undefined).

В то же время, вызовы фундаментальных методов, таких как #respondsTo:, #class или #isKindOf: практически всегда могут быть
сведены к обобщенной форме. Конечно, она будет не такой эффективной как прямая специализация, но зато может позволить избежать
полиморфного кэша вызовов для данного сайта, что может упростить последующий анализ и облегчить инлайнинг.

Более того, методы которые не содержат логики, зависящей от класса в контексте которого происходит вызов, следует по возможности
оформлять именно как дженерики. Специализация не принесет ничего нового, только лишь увеличит накладные расходы. Если метод
не обращается к self и super, не работает с полями а только лишь обрабатывает аргументы и временные значения, то он с большой вероятностью
является кандидатом на генерализацию. Потенциальный инлайнинг таких методов можно со спокойной душой отдать на откуп LLVM.

Тем не менее, обобщенные методы могут:
    - Читать аргументы, с ограничением на self
    - Разумеется, читать литералы
    - Писать поля инстанции, читать в режиме *
    - Читать и писать временные переменные
    - Работать с блоками

Отправка сообщений самому себе (self) и вверх по иерархии (super) возможна,
но реализуются динамически и с использованием полиморфного кэша.

Впрочем, ветви кэша кодируются как вызовы специализированных версий методов,
поскольку в пределах ветви класс отправителя (self) становится известен.

