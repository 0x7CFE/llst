Типы, как монадическая категория

Чистые функции без параметров:

	self::* -> self, 42
	foo
		^42

	self::* -> self, (SmallInt)
	rnd
		^SmallInt random


Чистые функции с параметрами:

Прямое связывание типа аргумента с типом функции
	id: param
		^param

Ти́повое выражение:
	self::*, param::* -> self, param


Функция с двумя параметрами:
	sum: a and: b
		^ a + b

Контекст object sum: intvara and: intvarb
	self::*, (SmallInt), (SmallInt) -> self, (SmallInt)

Контекст object sum: 2 and: 3
	self::*, a::2, b::3 -> self, 5

то есть, литеральные значения протаскиваются прямо через тип


Чистый аксессор для объекта с одним полем:
	self::[_,_,field::*] -> self, field
	field
		^field

Примитивный аксессор класса вне контекста:
	self::[_,class::*, ...] -> self, class
	class
		^<2> "примитив getClass"

В контексте Object new class ти́повое выражение будет:
	self::[_,class::Class,_] -> self, class

(здесь class — это литеральное значение объекта метакласса, соответствующее классу объекта Object)


«Чистый» мутатор (линза?):
	self::[_,_,_], value::* -> self'::[_,_,value], self'
	field: value
		field <- value

Функция с побочным эффектом на объект:
	dirty: param
		field <- param
		^param + 1

Вне контекста
	self::[_,_,_], param::* -> self'::[_,_,param], *

Контекст object dirty: intvar
	self::[_,_,_], param::(SmallInt) -> self'::[_,_,param], (SmallInt)

Контекст object dirty: 42
	self::[_,_,_], param::42 -> self'::[_,_,42], 43



А теперь самый вынос мозга — система контекста виртуальной машине — это монод в категории эндофункторов! Монада то бишь.
Переход виртуальной машины от одного состояния к другому — это монадическая операция.

А это внезапно означает:

1. Трансформации типов при выполнении императивной программы выражаются ФУНКЦИОНАЛЬНЫМИ отношениями!!

Появляется понятие чистой ти́повой функции, когда тип результата чистым образом зависит от входных данных.
2. Паттерн матчинг! Ти́повые выражения можно рассматривать как шаблон подстановки или отображение типа аргументов в тип результата

Можно описать трансформации типов в духе подстановочных функций Хаскеля.

Например оператор * в общем случае подчиняется следующим шаблонам (сверху-вниз):

Арифметические отношения (чистота self следует из определения):
	self::(SmallInt), 0 -> 0
	self::(SmallInt), 1 -> self::(SmallInt)

Отношения для монотипов и литералов в частном порядке:
	self::(SmallInt), (SmallInt) -> self'::(SmallInt)
	сюда подпадут выражения «(SmallInt) * 5» и «5 * (SmallInt)» и «2 * 3»

Последним идет определение для общего случая:
	self::*, (SmallInt) -> self'::*


Фишка в том, что в вырожденных случаях можно определить тип результата (вплоть до литерального!) даже не подставляя функцию.

Монадические отношения в связи с объектом self позволяют формализовать тот факт, что при вызове метода поля самого объекта не меняются.
Это позволяет более смело выполнять оптимизации и связывать далекие участки графа без опасения что типы совпали «случайно».



Типы методов:
	- С побочными эффектами (грязный)
	- Без побочных эффектов на поля
	- С грязными блоками
	- С чистыми блоками
	- Без побочных эффектов (чистый)

Имеем метод
	test: a |x|
		x <- 42.             
		a foo.               
		a bar: [ x <- false ]. 
		x <- 'Hello'.        
		a baz.

Вне контекста типы можно вывести следующим образом 
(указывается значение на момент сразу после выполнения строки):
		x <- 42.               "x :: 42"
		a foo.                 "x :: 42"
		a bar: [ x <- false ]. "x :: (42, false)"
		x <- 'Hello'.          "x :: (42, false, 'Hello')"
		a baz.                 "x :: (42, false, 'Hello')"


Если анализ докажет, что блок не вызывается ни разу, то тип переменной x выводится литерально на диапазонах:
		x <- 42.               "x :: 42"
		a foo.                 "x :: 42"
		a bar: [ x <- false ]. "x :: 42"
		x <- 'Hello'.          "x :: 'Hello'"
		a baz.                 "x :: 'Hello'"


Если анализ докажет, что блок вызывается только в пределах bar (то есть, bar не имеет побочных эффектов относительно блока),
то типы выводятся следующим образом:

		x <- 42.               "x :: 42"
		a foo.                 "x :: 42"
		a bar: [ x <- false ]. "x :: (42, false)"
		x <- 'Hello'.          "x :: 'Hello'"
		a baz.                 "x :: 'Hello'"


На основании полноты информации можно очертить диапазон возможных значений переменной при выполнении кода. 
Даже в условиях композитного типа в некоторых случаях можно провести анализ и девиртуализацию посылки сообщения.
В вышеприведенном методе, даже в худшем случае может быть показано, что переменная не выйдет за пределы диапазона 
(42, false, 'Hello'). Соответственно, последующие посылки сообщений объекту x можно выполнить с оптимизациями.

В частности, если посылается сообщение с селектором, которому соответствует один и тот же метод для всех трех ветвей поиска,
то его можно вызвать в режиме «type erasure». При этом, все обращения к полям, примитивам или self обрабатываются динамически.
Бестиповая реализация, будучи неспециализированной, может эффективно разделяться между многими классами тем самым экономя ресурсы.

В то же время, вызовы фундаментальных методов, таких как #respondsTo:, #class или #isKindOf: практически всегда могут быть
сведены к бестиповой форме. Конечно, она будет не такой эффективной как прямая специализация, но зато может позволить избежать
полиморфного кэша вызовов для данного сайта, что может упростить последующий анализ и облегчить инлайнинг.

Более того, методы которые не содержат логики, зависящей от класса в контексте которого происходит вызов, следует по возможности
оформлять именно как бестиповые. Специализация не принесет ничего нового, только лишь увеличит накладные расходы. Если метод
не обращается к self, не работает с полями а только лишь обрабатывает аргументы и временные значения, то он с большой вероятностью
является кандидатом на генерализацию. Инлайнинг таких методов можно со спокойной душой отдать на откуп LLVM.
