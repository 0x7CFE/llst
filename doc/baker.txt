Оптимизация алгоритма Бейкера

Идея: Использовать сразу оба пространства для хранения объектов, 
      но вместо равноправной организации левой и правой кучи,
      разделить их по поколениям. В одной куче будут жить текущие
      объекты, а в другой — объекты предыдущих поколений.
      
      
Введение:

Классический алгоритм Бейкера работает следующим образом. Имеется некоторое
заранее зарезервированное пространство памяти, называемое кучей:

                [                                        ]
                      
Оно было получено при старте менеджера памяти и целиком доступно для использования.
Алгоритм Бейкера делит его пополам и рассматривает как две отдельные кучи:

                [      Left          |      Right        ]
                
В каждый момент времени активной является только одна куча. Предположим что это левая.
Имеется указатель на базовый адрес кучи (base) и текущее смещение (top). 

                [      Left          |      Right        ]
                                     ^top
                ^base

Для выделения памяти под нужды объекта, текущий указатель top смещается на заданное 
количество байт в сторону младших адресов. Пространство правее указателя после этого 
считается занятым:

                [                 ***|      Right        ]
                                  ^top
                ^base
                
Операция сдвига указателя выполняется за одну ассмеблерную инструкцию, поэтому память
выделяется очень быстро. Достаточно вычесть из значения указателя размер объекта и вернуть 
получившееся число. Как только указатели base и top сравняются, можно говорить о том, что
куча заполнена. В этот момент необходимо произвести операцию сборки мусора.

                [********************|      Right        ]
                ^top
                ^base

Основное наблюдение, делающее подобный подход практичным заключается в том, что большая часть
объектов живет достаточно непродолжительное время. Их создается много, но они очень быстро
становятся ненужными. Количество выделений памяти не является проблемой, поскольку операция
выделения, как мы уже знаем, работает быстро.

Для сборки мусора необходимо отделить зерна от плевел, а именно активные, «живые» объекты от
«мертвых». «Живым» считается объект, на который ссылается другой живой объект. Тот в свою 
очередь, должен быть доступен из третьего и так далее. В конце концов мы приходим к корневым
объектам системы, содержащим указатели на прочие объекты системы. Корневые объекты считаются
живыми всегда.

В реальности, корневые объекты располагаются в отдельной статической куче, сборка мусора в которой 
как правило не производится:

                [    ssssssssss]
                    /   ||  | \
                [********************|      Right        ]
                ^ltop                                    ^rtop
                ^lbase               ^rbase                    

В процессе сборки мусора обход производится начиная с корневых объектов и дальше по иерархии ссылок.
Обнаруженные таким образом объекты кучи автоматически считаются живыми, поскольку мы нашли к ним путь.
Такие объекты переносятся в доселе не использованную неактивную кучу (Right).
                
После переноса всех живых объектов на новое место жительства, старое место отмечается как свободное,
по скольку в старой куче по определению не осталось живых объектов:
                
                                          [    ssssssssss]
                                                  |||||\\
                [        Left        |            *******]
                                     ^ltop        ^rtop
                ^lbase               ^rbase                    

После этого кучи меняются ролями. Теперь, новые объекты будут создаваться в правой куче, а как только
она переполнится, будет вновь инициирована операция сборки мусора и т.д.

Преимущества метода: 

1. Относительная простота реализации. Сложность представляет только алгоритм обхода дерева ссылок.
2. Финитность и гарантия результата: Поскольку дерево ссылок конечно, то алгоритм всегда сможет 
   завершиться, как только последний объект будет перенесен в новую кучу.
3. В отличие от методики mark & sweep, перебор дерева в глубину не оставляет шансов существованию 
   «островов», т.е. изолированных групп объектов, ссылающихся друг на друга, то есть все ссылки 
   которых не покидают пределов острова.

Недостатки:

1. Крайне неэффективное использование памяти. Для корректной работы алгоритма необходимо в 2 раза больше
   памяти, чем реально требуется для хранения объектов.

2. Имеются определенные алгоритмические сложности с увеличением размера кучи. Удобно увеличить размер блока
   памяти возможно только в случае если активной является левая куча. В случае если это не так, необходимо
   выполнить сборку еще раз.

   
   