Заметки, мысли и идеи.

* Косвенная адресация объектов vptr<TObject>
  Идея:  Поле объекта хранит не фактический адрес ссылаемого объекта, 
         а его виртуальный индекс.
         
  Например: 
            struct TDictionary {
                vptr<TSymbolArray> keys;
                vptr<TObjectArray> values;
            };

  Шаблонный класс vptr определяет операторы =, ->, * и возвращает адресуемый объект
  
  
  Использование:
  
  vptr<TDictionary> sample = vm.newObject<TDictionary>(); 
  
  В этом случае newObject() возвращает vptr<T>.
  sample->keys вернет указатель на поле действительного объекта точно так же, как
  если бы это был обычный указатель.
  
  
  Примерная реализация: 

  Для корректной работы шаблона необходимо общее требование, чтобы все объекты
  в памяти были выровнены по адресам, кратным 4. Таким образом младшие два бита
  реального адреса всегоа будут сброшены, что дает возможность хранить в этих
  битах полезную флаговую информацию.
  
  vptr<T> имеет поле uint32_t которое хранит два флага и 30 битное целое.
  В зависимости от флагов оно интерпретируется либо как inline integer (младший бит),
  либо как флаг косвенной адресации. 
  
                        32                  2   1
                        | 30 бит значения | S | I |
  
  Если установлен бит I, то оставшийся 31 бит интерпретируется как 31-битное целое
  Если бит I сброшен в 0, но установлен бит S, то указатель содержит РЕАЛЬНЫЙ адрес
  назначения, который возвращается без преобразования. Подразумевается, что такой 
  режим должен использоваться для доступа к объектам статической кучи, положение
  которых не меняется с течением времени. В таком режиме использование vptr<>
  полностью эквивалентно обычному указателю T*
  
  Если бит S сброшен, то 30 бит значения интерпретируются как некий индекс, адресующий
  запись в таблице преобразования адресов (ТПА).
  
  В коде операторов * и -> осуществляются вышеприведенные проверки и производится обращение
  к таблице преобразования адресов с тем, чтобы получить реальный адрес объекта. Этот
  реальный адрес возвращается в качетсве результата оператора.

  
  Преимущества: 
  
  Использование косвенной адресации позволяет существенно упростить механизм сборки мусора.
  В традиционном алгоритме Бейкера, как и во многих других реализованных на пользовательском
  уровне, после перемещения объекта требуется поправить ВСЕ ссылки на него из других мест.
  
  Частично эта проблема решается с помощью статической кучи, в которой хранятся все долгоживущие 
  объекты. Сборка в статической куче как правило не осуществляется.
  
  При использовании косвенной адресации становится возможным исключить этап правки адресов O(n)
  Вместо этого, изменяется одна единственная запись в таблице преобразования адресов O(1).
  
  Дполнительным преимуществом можно назвать возможность добавления оператора [], который упростит
  индексный доступ к полям адресуемого объекта:
        
        vptr<TObjectArray> array = vm.newObject<TObjectArray>(5);
        array[1] = globals.nilObject;
        array[2] = newInteger(42);
        array[3] = vm.newObject< TArray<TInteger> >(7);
        array[3][2] = newInteger(7);
  
  Недостатки:
  
  1. Достигается это ценой одного промежуточного обращения к памяти на КАЖДУЮ операцию доступа 
  к данным объекта. Последствия этого изменения еще предстоит выяснить, однако наличие большого 
  кэша данных у современных процессоров может существенным образом нивелировать данный эффект.
  
  2. Пока еще не совсем понятно, как именно должна выглядеть таблица преобразования адресов и 
  какого вида индексы должны храниться в vptr<T>. Должен ли это быть простой целочисленный индекс, 
  показывающий индекс записи в ТПА, или же это должен быть хеш - непонятно.
  

