Оптимизация алгоритма Бейкера

Идея: Использовать сразу оба пространства для хранения объектов, 
      но вместо равноправной организации левой и правой кучи,
      разделить их по поколениям. В одной куче будут жить текущие
      объекты, а в другой — объекты предыдущих поколений.
      
      
Введение:

Классический алгоритм Бейкера работает следующим образом. Имеется некоторое
заранее зарезервированное пространство памяти, называемое кучей:

                [                                        ]
                      
Оно было получено при старте менеджера памяти и целиком доступно для использования.
Алгоритм Бейкера делит его пополам и рассматривает как две отдельные кучи:

                [      Left          |      Right        ]
                
В каждый момент времени активной является только одна куча. Предположим, что это левая.
Имеется указатель на базовый адрес кучи (base) и текущее смещение (top). Смещение отсчитывается
начиная с конца кучи и направлено в сторону базы:

                [      Left          |      Right        ]
                                     ^top
                ^base

Для выделения памяти под нужды объекта, текущий указатель top смещается на заданное 
количество байт в сторону младших адресов. Пространство правее указателя после этого 
считается занятым:

                [                 ***|      Right        ]
                                  ^top
                ^base
                
Операция сдвига указателя выполняется за одну ассмеблерную инструкцию, поэтому память
выделяется очень быстро. Достаточно вычесть из значения указателя размер объекта и вернуть 
получившееся число. Как только указатели base и top сравняются, можно говорить о том, что
куча заполнена. В этот момент необходимо произвести операцию сборки мусора.

                [********************|      Right        ]
                ^top
                ^base

Основное наблюдение, делающее подобный подход практичным заключается в том, что большая часть
объектов живет достаточно непродолжительное время. Их создается много, но они очень быстро
становятся ненужными. Количество выделений памяти не является проблемой, поскольку операция
выделения, как мы уже знаем, работает быстро.

Для сборки мусора необходимо отделить зерна от плевел, а именно активные, «живые» объекты от
«мертвых». «Живым» считается объект, на который ссылается другой живой объект. Тот в свою 
очередь, должен быть доступен из третьего и так далее. В конце концов мы приходим к корневым
объектам системы, содержащим указатели на прочие объекты системы. Корневые объекты считаются
живыми всегда.

В реальности, корневые объекты располагаются в отдельной статической куче, сборка мусора в которой 
как правило не производится:

                [    ssssssssss]
                    /   ||  | \
                [********************|      Right        ]
                ^ltop                                    ^rtop
                ^lbase               ^rbase                    

В процессе сборки мусора обход производится начиная с корневых объектов и дальше по иерархии ссылок.
Обнаруженные таким образом объекты кучи автоматически считаются живыми, поскольку мы нашли к ним путь.
Такие объекты переносятся в доселе не использованную неактивную кучу (Right).
                
После переноса всех живых объектов на новое место жительства, старое место отмечается как свободное,
поскольку в старой куче по определению не осталось живых объектов:
                
                                          [    ssssssssss]
                                                  |||||\\
                [        Left        |            *******]
                                     ^ltop        ^rtop
                ^lbase               ^rbase                    

После этого кучи меняются ролями. Теперь, новые объекты будут создаваться в правой куче, а как только
она переполнится, будет вновь инициирована операция сборки мусора и т.д.

Преимущества метода: 

1. Относительная простота реализации. Сложность представляет только алгоритм обхода дерева ссылок.
2. Финитность и гарантия результата: Поскольку дерево ссылок конечно, то алгоритм всегда сможет 
   завершиться, как только последний объект будет перенесен в новую кучу.
3. В отличие от методики mark & sweep, перебор дерева в глубину не оставляет шансов существованию 
   «островов», т.е. изолированных групп объектов, ссылающихся друг на друга, то есть все ссылки 
   которых не покидают пределов острова.

Недостатки:

1. Крайне неэффективное использование памяти. Для корректной работы алгоритма необходимо в 2 раза больше
   памяти, чем реально требуется для хранения объектов.

2. Имеются определенные алгоритмические сложности с увеличением размера кучи. Удобно увеличить размер блока
   памяти возможно только в случае если активной является левая куча. В случае если это не так, необходимо
   выполнить сборку еще раз.

   

Модифицированный алгоритм Бейкера с поддержкой поколений объектов   

В этом случае, исходный блок памяти так же делится на две части, однако части не равноправны и служат разным целям.

                [      Current       |     Reserved      ]
                ^base
                
В данном случае, по мере создания объектов, указатель вершины кучи будем двигать слева-направо:
                
                [*****               |                   ]
                     ^top
                ^base
                
Как только указатель вершины достигает медианы (границы, разделяющей пространства), инициируется процедура 
сборки мусора. Принципы обхода и идентификации живых объектов полностью эквивалентны классической методике,
однако на этом сходство заканчивается. Изобразим почти полную кучу, в которой большая часть объектов мертва
(как и происходит обычно в реальности):

                [*---**-*---*-----*-*|                   ]
                                     ^top
                ^base

Здесь мы звездочками обозначили живые объекты, а минусами — мертвые, которые, тем не менее занимают место.
В процессе идентификации живых объектов, мы переносим их во вторую половину пространства памяти:

                [*---**-*---*-----*-*|*******            ]
                                     ^ltop  ^rtop
                ^lbase               ^rbase

Мы очищаем левую кучу, сдвигая указатель вершины на начало. 

                [                    |*******            ]
                ^ltop                       ^rtop
                ^lbase               ^rbase

А теперь самое главное. Новые объекты мы начинаем создавать опять в левой половине. 
Правая остается нетронутой но активной, поскольку содержит некоторое количество живых объектов:

                                                                   Поколения:
                [****                |XXXXXXX            ]         
                    ^ltop                   ^rtop                  * - нулевое
                ^lbase               ^rbase                        X - первое

Здесь мы отметили предыдущее поколение символами X, а новое, текущее поколение по прежнему обозначается звездочками.
Через некоторое время, ситуация повторится. В левой половине накопится большое количество мертвых объектов и некоторое
количество живых. Когда память в левой части закончится, мы вновь переносим живые объекы нулевого поколения к первому
поколению, расположенному в правой части:
                                                                   
                [                    |XXXXXXXYYYY        ]         
                ^ltop                           ^rtop              
                ^lbase               ^rbase                        

И опять ситуация повторяется:
                
                [********            |XXXXXXXYYYY        ]          Поколения:
                        ^ltop                   ^rtop               
                ^lbase               ^rbase                         * - нулевое
                                                                    X - третье
                [                    |XXXXXXXYYYYZZZZZ   ]          Y - второе
                ^ltop                                ^rtop          Z - первое
                ^lbase               ^rbase

Обратите внимание: несмотря на то, что при обходе указателей задействованы объекты из обеих частей
кучи, реально перемещаются только объекты из левой половины. Правая при этом остается на своем месте.

Не забываем, что при перемещении объекта необходимо не только скопировать его данные, но и поправить
все указатели других объектов, которые ссылаются на текущий. Во всех местах! В случае популярных объектов,
накладные расходы, связанные с правкой адресов могут быть гораздо выше чем стоимость самого перемещения объекта
в памяти (которое является обычной операцией копирования массива байт и легко выполняется процессором). 

Именно поэтому, механизм сборки, основанный на идее поколений, оказывается настолько эффективным.


Но что делать, если закончится место в правой части? В этом случае мы поступаем следующим образом. Выполняя
текущие сборки мусора, мы следим за заполнением правой части. Как только, после очередной сборки, заполнение 
превысит определенный порог, мы повторно выполняем сборку мусора. Но только в этот раз мы переносим объекты 
из правой части назад, в левую:

                [                    |-X-X-XX-Y-YZZ-ZZ   ]
                ^ltop                                ^rtop
                ^lbase               ^rbase

По мере работы программы, часть долгоживущих объектов все же станет неактивной, поэтому их можно собрать, 
освободив занимаемую ими память в такой полезной (с точки зрения эффективности) правой части:

                [**********          |                   ]
                          ^ltop      ^rtop
                ^lbase               ^rbase

После переноса объектов мы «забываем» о поколениях и просто считаем кучу частично заполненной, как это было на 
втором рисуке этой части. Не беда, после первой же сборки мусора, старые, долгоживущие объекты опять переедут
на облюбованное ими место в правой части кучи и останутся там еще очень долго, пока правая часть не заполнится.

                [                    |XXXXX              ]
                ^ltop                     ^rtop
                ^lbase               ^rbase

Дальше, все повторяется снова. 
                

Заключение

Описанный выше модифицированный алгоритм Бейкера позволяет существенно оптимизировать работу сборщика мусора 
сразу по нескольким параметрам.

1. Существенно сокращается типичное время сборки, поскольку большую часть времени мы производим т.н. быструю 
   сборку, когда затрагиваются только объекты нулевого поколения. Полная же сборка выполняется сравнительно редко,
   поэтому существенного влияния на общую статистику не оказывает. Отношение полной к частичым сборкам может
   достигать 1/10 и более, в зависимости от характера использования памяти программой.
                
2. В нормальных условиях мы эффективно используем порядка 75% выделенной нам памяти, в противовес ~50% Бейкера.

3. Для достижения оптимального эффекта мы можем собирать статистику по характеру использования памяти и изменять 
   положение медианы для достижения оптимального соотношения памяти под хранение кратковременных и 
   долговременных объектов. Целесообразно собирать статистику по быстрым сборкам, а именно, какой процент объектов
   нулевого поколения остается живым. Таким образом, к моменту наступления полной сборки мы сможем рассчитать новое
   положение медианы, учитывающее текущие потребности программы.

4. Специфика работы сборщика позволяет детектировать момент, когда необходимо увеличить кучу.
   
                [                    |XXXXXXXYYYYZZZZZ   ]          
                ^ltop                                ^rtop          
                ^lbase               ^rbase
                
   Этот момент представлен на рисунке и иллюстрирует состояние сразу после последней быстрой сборки, после которой
   необходимо либо выполнить полную сборку мусора, либо увеличить кучу, если это сочтено целесообразным. В этом
   случае, выполняется операция realloc увеличивающая фактический размер кучи;  затем объекты переносятся в левую 
   часть:
                
                [*********           |                   ............]
                         ^ltop       ^rtop          
                ^lbase               ^rbase
                
   После этой операции можно заново выставить медиану в соответствии с увеличившимся объемом доступной памяти:             
                
                [*********                    |          ............]
                         ^ltop                ^rtop          
                ^lbase                        ^rbase
   
   Вынужденное увеличение кучи также может быть выполнено в середине быстрой сборки, если выясняется, что полностью
   переместить все живые объекты в правую часть невозможно:
                
                [  - **-***--*******-|XXXXXXXYYYYZZZZZ***]          
                                    ^ltop                ^rtop          
                ^lbase               ^rbase
   
   Звездочки в правой части рисунка обозначают частично перемещенные объекты нулевого поколения. В этом случае, 
   так же производится увеличение объема кучи, с последующими стадиями окончания частичной и выполнения полной сборки.

   
5. Модифицированный алгоритм Бейкера позволяет хорошо спрогнозировать пиковое потребление памяти программой и 
   оценить оптимальный размер кучи.

6. Можно организовать более сложную иерархию кучи, разделив ее не на две а на три части. Соответственно, после заполения
   второй части, объекты переносятся в третью. Однако подобная практика должна быть хорошо просчитана, с тем чтобы избежать
   простоя памяти.
   
Алгоритм сборки с overallocation:

moveObject(TMovableObject* object)

- Если объект это smallint, вернуть его как есть
- Если объект уже перемещен, то в качестве результата вернуть indirection
- Если объект бинари, то: переместить объект и его данные; 
  переместить класс; вернуть перемещенный объект
- Если объект обычный, то: переместить объект, рекурсивно переместить его поля; 
  вернуть перемещенный объект
      