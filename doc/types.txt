Типы, как монадическая категория

Чистые функции без параметров:

    self::* -> self, 42
    foo
        ^42

    self::* -> self, (SmallInt)
    rnd
        ^SmallInt random


Чистые функции с параметрами:

Прямое связывание типа аргумента с типом функции
    id: param
        ^param

Т́иповое выражение:
    self::*, param::* -> self, param


Функция с двумя параметрами:
    sum: a and: b
        ^ a + b

Контекст object sum: intvara and: intvarb
    self::*, a::(SmallInt), b::(SmallInt) -> self', (SmallInt)

Контекст object sum: 2 and: 3
    self::*, a::2, b::3 -> self, 5

Обобщенный метод
    self::*, a::*, b::* -> self', *

то есть, литеральные значения протаскиваются прямо через тип


Чистый аксессор для объекта с одним полем:
    self::[_,_,field::*] -> self, field
    field
        ^field

Примитивный аксессор класса вне контекста:
    self::[_,class::*, ...] -> self, class
    class
        ^<2> "примитив getClass"

В контексте Object new class ти́повое выражение будет:
    self::[_,class::Class,_] -> self, class

(здесь class — это литеральное значение объекта метакласса, соответствующее классу объекта Object)


«Чистый» мутатор (линза?):
    self::[_,_,_], value::* -> self'::[_,_,value], self'
    field: value
        field <- value

Функция с побочным эффектом на объект:
    dirty: param
        field <- param
        ^param + 1

Вне контекста
    self::[_,_,_], param::* -> self'::[_,_,param], *

Контекст object dirty: intvar
    self::[_,_,_], param::(SmallInt) -> self'::[_,_,param], (SmallInt)

Контекст object dirty: 42
    self::[_,_,_], param::42 -> self'::[_,_,42], 43

Примечание: в случае утекания self, мы не можем утверждать, что self' будет таким. Придется фолбечиться на self'::*


А теперь самый вынос мозга — система контекста виртуальной машине — это моноид в категории эндофункторов! Монада то бишь.
Переход виртуальной машины от одного состояния к другому — это монадическая операция.

А это внезапно означает:

1. Трансформации типов при выполнении императивной программы выражаются ФУНКЦИОНАЛЬНЫМИ отношениями!!

Появляется понятие чистой ти́повой функции, когда тип результата чистым образом зависит от входных данных.
2. Паттерн матчинг! Ти́повые выражения можно рассматривать как шаблон подстановки или отображение типа аргументов в тип результата

Можно описать трансформации типов в духе подстановочных функций Хаскеля.

Например оператор * в общем случае подчиняется следующим шаблонам (сверху-вниз):

Арифметические отношения (чистота self следует из определения):
    self::(SmallInt), 0 -> self, 0
    self::(SmallInt), 1 -> self, (SmallInt)

Отношения для монотипов и литералов в частном порядке:
    self::(SmallInt), (SmallInt) -> self, (SmallInt)
    сюда попадут выражения «(SmallInt) * 5» и «5 * (SmallInt)» и «2 * 3»

Последним идет определение для общего случая:
    self::*, (SmallInt) -> self'::*, *


Фишка в том, что в вырожденных случаях можно определить тип результата (вплоть до литерального!) даже не подставляя функцию.
Более того, для литеральных контекстов можно вычислить значение функции даже на этапе компиляции.

Монадические отношения в связи с объектом self позволяют формализовать тот факт, что при вызове метода поля самого объекта не меняются.
Это позволяет более смело выполнять оптимизации и связывать далекие участки графа без опасения что типы совпали «случайно».

Поправка — нихрена :( Если self утек в другой объект, то вызывая методы он может поменять и нас. Только при инлайнинге и доказательсве.


Типы методов:
    - С побочными эффектами (грязный)
    - Без побочных эффектов на поля
    - С грязными блоками
    - С чистыми блоками
    - Без побочных эффектов (чистый)

Имеем метод
    test: a |x|
        x <- 42.
        a foo.
        a bar: [ x <- false ].
        x <- 'Hello'.
        a baz.

Вне контекста типы можно вывести следующим образом
(указывается значение на момент сразу после выполнения строки):
        x <- 42.               "x :: 42"
        a foo.                 "x :: 42"
        a bar: [ x <- false ]. "x :: (42, false)"
        x <- 'Hello'.          "x :: 'Hello'"
        a baz.                 "x :: ('Hello', false)"


Если анализ докажет, что блок не вызывается ни разу, то тип переменной x выводится литерально на диапазонах:
        x <- 42.               "x :: 42"
        a foo.                 "x :: 42"
        a bar: [ x <- false ]. "x :: 42"
        x <- 'Hello'.          "x :: 'Hello'"
        a baz.                 "x :: 'Hello'"


Если анализ докажет, что блок вызывается только в пределах bar (то есть, bar не имеет побочных эффектов относительно блока),
то типы выводятся следующим образом:

        x <- 42.               "x :: 42"
        a foo.                 "x :: 42"
        a bar: [ x <- false ]. "x :: (42, false)"
        x <- 'Hello'.          "x :: 'Hello'"
        a baz.                 "x :: 'Hello'"


На основании полноты информации можно очертить диапазон возможных значений переменной при выполнении кода.
Даже в условиях композитного типа в некоторых случаях можно провести анализ и девиртуализацию посылки сообщения.
В вышеприведенном методе, даже в худшем случае может быть показано, что переменная не выйдет за пределы диапазона
(42, false, 'Hello'). Соответственно, последующие посылки сообщений объекту x можно выполнить с оптимизациями.

В частности, если посылается сообщение с селектором, которому соответствует один и тот же метод для всех трех ветвей поиска,
то его можно вызвать обобщенном режиме. При этом, все обращения к полям, примитивам, self/super обрабатываются динамически.
Обобщенная реализация, будучи неспециализированной, может эффективно разделяться между многими классами, тем самым экономя ресурсы.

Например выражение x isNil может быть вычислено на этапе компиляции до литерального результата false, посколько для любой
из возможных ветвей результат будет идентичным (ни одна из ветвей не является потомком Undefined).

В то же время, вызовы фундаментальных методов, таких как #respondsTo:, #class или #isKindOf: практически всегда могут быть
сведены к обобщенной форме. Конечно, она будет не такой эффективной как прямая специализация, но зато может позволить избежать
полиморфного кэша вызовов для данного сайта, что может упростить последующий анализ и облегчить инлайнинг.

Более того, методы которые не содержат логики, зависящей от класса в контексте которого происходит вызов, следует по возможности
оформлять именно как дженерики. Специализация не принесет ничего нового, только лишь увеличит накладные расходы. Если метод
не обращается к self и super, не работает с полями а только лишь обрабатывает аргументы и временные значения, то он с большой вероятностью
является кандидатом на генерализацию. Потенциальный инлайнинг таких методов можно со спокойной душой отдать на откуп LLVM.

Тем не менее, обобщенные методы могут:
    - Читать аргументы, с ограничением на self
    - Разумеется, читать литералы
    - Писать поля инстанции, читать в режиме *
    - Читать и писать временные переменные
    - Работать с блоками

Отправка сообщений самому себе (self) и вверх по иерархии (super) возможна,
но реализуются динамически и с использованием полиморфного кэша.

Впрочем, ветви кэша кодируются как вызовы специализированных версий методов,
поскольку в пределах ветви класс отправителя (self) становится известен.


Блоки, акт второй.

Классификация блоков относительно типов
    ContextFree         [ 42 ], [ :x | x + 1 ], [ :x :y | x < y ]
    ContextAccessor     [ x message ], [ x + 1 ], [ anArgument message: aTemporary ]
    ContextMutator      [ x <- nil ], [ :x | sum <- sum + x ]

    BlockReturn         [ ^42 ]

Классификация точки вызова блоков
    Never
    Once                y <- [ :x | x ] value: 42
    Maybe               <Never + Once>
    Multi               1 to: 10 do: [ :x | sum <- sum + x ]
    Escape              *::anObject take: (Block)::aBlock


В зависимости от вида блока и точки его вызова, вывод типов может быть реализован по-разному.

В наиболее общем случае необходимо выполнять подстановку графа блока в лексический контекст
вызывающего метода в зависимости от того как происходит работа с блоком в теле обработчика сообщения.

Never
    Блок не учитывается в выводе типов

Once
    Блок подключается параллельно инструкции, принимающей его параметром, например 1 to: 10: do: [ ... ]

Maybe
    То же, что и для Once, но есть параллельное ребро мимо блока

Multi
    То же, что и Multi, но еще добавляется возвратное ребро в начало блока

Escape
    Вызовы этого типа не могут быть представлены в виде графа и блокируют вывод типов для задействованных переменных

После построения inline графа, выполняется проход TauLinker-а на нем,
полученные тау узлы могут быть использованы для вывода типов переменных.


Итак, алгоритм.

Для метода, в лексическом контексте которого объявляется блок:
    1. Получаем список переменных, которые мутирует блок (известно после анализа графа блока)
    2. Выполняем анализ для каждой посылки, которая использует блок как параметр
    3. В точку вызова передаем тип всех временных переменных, используемых блоком (как аргументы)
    4. После анализа посылки изучаем контекст на предмет поменявшихся типов переменных
    5. Если тип поменялся, то маркируем текущую посылку как мутатор
    6. После маркировки всех мутаторов обновляем тау узлы графа и точки их использования
    7. Пересчитываем все заново с обновленным графом (новых мутаторов добавиться не должно)

Для метода, принимающего литеральный блок параметром:
    1. В каждой посылке, использующей переданный аргументом блок выполняем анализ «как есть»
    2. Аккумулируем типы меняющихся переменных
    3. Возвращаем аккумулированный результат

Для методов Block>>value* (код обработчика примитива 8)
    1. Проводим анализ блока, передав типы аргументов и переменных
    2. Получаем типы переменных и результата
    3. Возвращаем все добро наверх


Проходы анализатора, в зависимости от типа метода:
    1. Метод, не содержащий ветвлений доказывается за 1 проход
    2. Метод, с литеральными условиями при ветвлениях доказывается за 1 проход
    3. Метод, не содержащий циклов (обратных ребер) доказывается за 1 проход
    4. Метод, содержащий циклы, но не имеющий тау узлов с обратными ребрами, доказывается за 1? проход
    5. Метод, содержащий циклы и имеющий циклическую зависимость по данным (x <- x + 1), доказывается за 2 прохода

    6. Метод, содержащий литеральные блоки, вне циклов: если нет замыканий или только читают — 1 проход, если пишут — минимум 2 прохода
    7. Метод, содержащий литеральные блоки, в циклах — минимум 3 прохода
    8. Метод, содержащий литеральные блоки, записанные в переменную

    Блоки, вызываемые несколько раз (утекающие в поле) не могут быть выведены, без отслеживания полей

    9. Метод, содержащий литеральные блоки, утекающие в неизвестность — полная блокировка вывода переменных, которые они пишут


Алгоритм анализатора:
    1. Делаем базовый проход без обратных ребер
    2. Если предыдущий проход вывел возврат по литеральному пути и метод не содержит блоков мутаторов — выход
    3. Делаем базовый проход с нетривиальными мутаторами
    4. Если есть литеральный возврат — выход
    5. Делаем индукционный переход

